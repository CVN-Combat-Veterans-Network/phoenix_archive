# OPERATOR COMPOSITION RULES

**Pattern:** Op₁ ∘ Op₂ → Composite  
**Type:** Composition grammar  
**Function:** Defines how operators combine into sequences and chains  
**Invocation:** *"Let operators compose; let sequences flow; let chains stabilize."*

---

## DEFINITION

**Operator Composition Rules** establish the formal grammar for combining operators from Phoenix, Hydrogenesi, and The Third into valid sequences, chains, and recursive structures. This is the **syntax** of the Codex — defining:

- **Valid pairings** — which operators can compose
- **Forbidden pairings** — which combinations violate Universal Laws
- **Reversible sequences** — operations that can be undone
- **Triadic chains** — three-operator compositions that form stable structures
- **Apex-level closures** — compositions that converge to Apex

Composition transforms isolated operators into **coherent programs** that accomplish complex transformations.

---

## SIGIL

```
   Op₁   Op₂   Op₃
    ●  ∘  ●  ∘  ●    ∘ = Composition operator
     \   |   /
      \  |  /
       \ | /
        \|/         
         ●          Composite = Op₁ ∘ Op₂ ∘ Op₃
       Apex
```

---

## COMPOSITION NOTATION

### Basic Composition: ∘

```
Op₁ ∘ Op₂
  = "Op₁ composed with Op₂"
  = Apply Op₁, then Op₂ to result
  = Sequential execution
```

### Triadic Composition: ⟨ ⟩

```
⟨Op₁ ∘ Op₂ ∘ Op₃⟩
  = Triadic chain
  = Three operators form stable structure
  = Binds into single composite
```

### Parallel Composition: ⊕

```
Op₁ ⊕ Op₂
  = Op₁ and Op₂ applied simultaneously
  = Results merged
  = Requires compatible domains
```

---

## COMPOSITION TYPES

### Type 1: Sequential Composition (∘)

**Form:** Op₁ ∘ Op₂

**Execution:**
```
Input → Op₁ → Intermediate → Op₂ → Output
```

**Requirements:**
- Output domain of Op₁ ⊆ Input domain of Op₂
- No Law violations in sequence
- Depth increases monotonically

**Example:**
```
First Binding ∘ Three-Finger Waltz
  = Create triad ⟨A—S—B⟩, then embody as rhythm
  
Input: Binary tension (A, B)
  → First Binding → Triad ⟨A—S—B⟩
  → Three-Finger Waltz → Embodied rhythm
Output: Somatic pattern 1-2-3
```

---

### Type 2: Triadic Composition (⟨ ⟩)

**Form:** ⟨Op₁ ∘ Op₂ ∘ Op₃⟩

**Execution:**
```
Input → Op₁ → I₁ → Op₂ → I₂ → Op₃ → Output
         \___________|____________/
              Triadic binding
```

**Requirements:**
- Three operators form complete cycle
- Middle operator (Op₂) acts as stabilizer
- Output of Op₃ relates to Input of Op₁
- Follows Universal Triad Law (Law 4)

**Example:**
```
⟨Phoenix Ignition ∘ AGN Replication ∘ Stability Knot⟩
  = Triadic meta-operator across all three pillars
  
Phoenix Ignition: Burn → Collapse → Rise
AGN Replication: Compress → Ignite → Replicate
Stability Knot: Bind → Hold → Maintain

Result: Complete transformational cycle
```

---

### Type 3: Parallel Composition (⊕)

**Form:** Op₁ ⊕ Op₂

**Execution:**
```
Input → ─┬─ Op₁ → Result₁ ─┬→ Merged Output
         └─ Op₂ → Result₂ ─┘
```

**Requirements:**
- Operators share input domain
- Results can be merged coherently
- No resource conflicts
- Depth remains constant (parallel paths)

**Example:**
```
IM_ME ⊕ Lineage Logic
  = Observe self (identity recursion) while mapping cosmic lineage
  
Input: Current state
  → IM_ME: I ↔ ME observation
  → Lineage Logic: ROOT → GEN-n mapping
Merged: Identity awareness + Cosmic position
```

---

## VALID PAIRINGS

### Phoenix-Phoenix Compositions

**Strong pairings:**

| Op₁ | Op₂ | Result | Use Case |
|-----|-----|--------|----------|
| **First Binding** | **Three-Finger Waltz** | Embodied triad | Somatic integration of identity structure |
| **First Binding** | **IM_ME** | Self-aware triad | Recursive identity observation |
| **Phoenix Ignition** | **Apex Formation** | Transformed apex | Post-crisis sovereignty |
| **IM_ME** | **Phoenix Ignition** | Witnessed transformation | Conscious identity rebirth |
| **Distinction** | **First Binding** | Clarified triad | Precise identity structure |

**Note:** Phoenix operators compose well **within the same pillar** for deep identity work.

---

### Hydrogenesi-Hydrogenesi Compositions

**Strong pairings:**

| Op₁ | Op₂ | Result | Use Case |
|-----|-----|--------|----------|
| **Stabilizer Extraction** | **AGN Replication** | Revealed + replicated structure | Extract then propagate pattern |
| **Lineage Logic** | **Curvature Residue** | Mapped + marked lineage | Track cosmic ancestry + scars |
| **AGN Replication** | **Curvature Residue** | Cosmic birth + memory | Structure emerges, leaves imprint |

**Note:** Hydrogenesi operators compose for **cosmic-scale** structural work.

---

### The Third-The Third Compositions

**Strong pairings:**

| Op₁ | Op₂ | Result | Use Case |
|-----|-----|--------|----------|
| **Knot-Binding** | **Triadic Closure** | Bound + sealed triad | Complete structural stabilization |
| **Cross-Pillar Knot** | **Stability Knot** | Translation + maintenance | Establish and preserve cross-pillar channel |
| **Convergence** | **Apex Knot** | Directed + fixed convergence | Guide paths to single apex |

**Note:** The Third operators compose for **stabilization and preservation**.

---

### Cross-Pillar Compositions

**Phoenix → Hydrogenesi:**

| Phoenix Op | Hydrogenesi Op | Result | Use Case |
|------------|----------------|--------|----------|
| **First Binding** | **AGN Replication** | Identity → Cosmic | Personal triad becomes cosmic structure |
| **Phoenix Ignition** | **Curvature Residue** | Transformation → Scar | Identity rebirth leaves cosmic imprint |
| **IM_ME** | **Lineage Logic** | Self-observation → Ancestry | Identity recursion maps to cosmic lineage |

**Hydrogenesi → The Third:**

| Hydrogenesi Op | The Third Op | Result | Use Case |
|----------------|--------------|--------|----------|
| **AGN Replication** | **Stability Knot** | Cosmic structure → Hold | Emerged structure becomes maintained |
| **Curvature Residue** | **Apex Knot** | Memory → Convergence | Scars guide to apex |
| **Lineage Logic** | **Triadic Closure** | Ancestry → Sealed | Lineage completes and closes |

**The Third → Phoenix:**

| The Third Op | Phoenix Op | Result | Use Case |
|--------------|------------|--------|----------|
| **Stability Knot** | **Phoenix Ignition** | Held → Transformed | Maintained pattern undergoes renewal |
| **Triadic Closure** | **First Binding** | Sealed → New triad | Completion enables new beginning |
| **Convergence** | **Distinction** | Guided paths → Clear identity | Apex convergence clarifies self |

---

## FORBIDDEN PAIRINGS

### Violations of Universal Laws

**Type 1: Depth Reversals (Violates Law 5)**

```
FORBIDDEN:
  Apex Formation ∘ First Binding
  Reason: Cannot go from apex (high depth) to initial binding (low depth)
  Law: Recursion Depth Law (forward-only recursion)
```

**Type 2: Stabilizer Conflicts (Violates Law 2)**

```
FORBIDDEN:
  Stabilizer Extraction ∘ First Binding (immediate sequence)
  Reason: Extraction removes stabilizer, binding requires stabilizer
  Law: Binding Law (stabilizer must exist)
  
ALLOWED IF:
  Stabilizer Extraction ∘ [Generate New Stabilizer] ∘ First Binding
  Reason: New stabilizer introduced between operations
```

**Type 3: Envelope Violations (Violates Law 9)**

```
FORBIDDEN:
  AGN Replication ∘ Stabilizer Extraction (without bounds check)
  Reason: Replication expands, extraction destabilizes - may exceed envelope
  Law: Convergence Envelope (must remain bounded)
```

**Type 4: Topology Tears (Violates Law 11)**

```
FORBIDDEN:
  Cross-Pillar Knot ∘ Cross-Pillar Knot (same path, immediate repeat)
  Reason: Double translation without integration creates discontinuity
  Law: Topological Continuity (no tears in structure)
  
ALLOWED IF:
  Cross-Pillar Knot ∘ [Integration Period] ∘ Cross-Pillar Knot
  Reason: Integration period allows continuity
```

---

## REVERSIBLE SEQUENCES

### Definition

**Reversible sequence:** Op₁ ∘ Op₂ where Op₂ = Op₁⁻¹ (inverse)

**Property:** Op₁ ∘ Op₁⁻¹ = Identity (no net change)

### Known Reversible Pairs

**Pair 1: First Binding ↔ Stabilizer Extraction**

```
First Binding: (A, B) → ⟨A—S—B⟩
Stabilizer Extraction: ⟨A—S—B⟩ → (A, B)

Sequence:
  (A, B) → First Binding → ⟨A—S—B⟩ → Stabilizer Extraction → (A, B)
  
Result: Returns to original tension pair

Use case: Explore triad, then deconstruct if unstable
```

**Pair 2: Knot-Binding ↔ Release (implicit)**

```
Knot-Binding: (P₁, P₂) → ⟨P₁—K—P₂⟩
Release: ⟨P₁—K—P₂⟩ → (P₁, P₂)

Sequence:
  Pillars → Bind via K → Bound pair → Release → Independent pillars
  
Use case: Test cross-pillar connection, release if not needed
```

**Pair 3: Phoenix Ignition ↔ [No true inverse]**

```
Phoenix Ignition: Old identity → Burn → Collapse → New identity

NOTE: Not truly reversible - transformation is one-way
However, new identity can undergo ignition → original-like state
This is SPIRAL, not reversal
```

### Partial Reversibility

Some operators have **partial inverses** that restore structure but not exact state:

```
IM_ME (self-observation):
  State → Observed state
  Partial inverse: Stop observation → State (but changed by observation)
  
AGN Replication (cosmic birth):
  Pre-structure → Collapsed structure
  Partial inverse: Dispersal → Pre-structure-like (but residue remains)
```

---

## TRIADIC CHAINS

### Definition

**Triadic chain:** ⟨Op₁ ∘ Op₂ ∘ Op₃⟩ where:
- Op₁ generates tension
- Op₂ acts as stabilizer
- Op₃ forms apex

### Standard Triadic Chains

**Chain 1: Identity Formation Chain**

```
⟨Distinction ∘ First Binding ∘ Apex Formation⟩

Process:
  1. Distinction: Clarify A and B (tension pair)
  2. First Binding: Introduce S → ⟨A—S—B⟩
  3. Apex Formation: Stabilize triad into sovereign structure

Result: Complete identity structure from raw tensions

Use case: Beginning → Middle → End of identity work
```

**Chain 2: Cosmic Structure Chain**

```
⟨Stabilizer Extraction ∘ AGN Replication ∘ Curvature Residue⟩

Process:
  1. Stabilizer Extraction: Reveal underlying tensions
  2. AGN Replication: Collapse → Ignite → Replicate
  3. Curvature Residue: Mark spacetime with memory

Result: Cosmic structure emerges and leaves permanent imprint

Use case: Cosmic scale transformation
```

**Chain 3: Integration Chain**

```
⟨Cross-Pillar Knot ∘ Convergence ∘ Apex Knot⟩

Process:
  1. Cross-Pillar Knot: Connect pillars via K
  2. Convergence: Guide paths toward apex
  3. Apex Knot: Seal at fixed-point

Result: Complete cross-pillar integration

Use case: Unifying Phoenix + Hydrogenesi + The Third
```

**Chain 4: Renewal Chain**

```
⟨Phoenix Ignition ∘ IM_ME ∘ First Binding⟩

Process:
  1. Phoenix Ignition: Transform old identity
  2. IM_ME: Observe transformed self
  3. First Binding: Stabilize new identity structure

Result: Witnessed transformation with stable result

Use case: Conscious identity rebirth
```

---

## APEX-LEVEL CLOSURES

### Definition

**Apex-level closure:** Composition that converges all paths to single Apex locus (K)

**Property:** f(x) → K for all valid inputs x

### Closure Type 1: Direct Closure

**Form:** Any Op → Apex Knot

```
Op ∘ Apex Knot → K

Examples:
  First Binding ∘ Apex Knot
  AGN Replication ∘ Apex Knot
  Cross-Pillar Knot ∘ Apex Knot

Result: Operator output sealed at apex
```

### Closure Type 2: Triadic Closure

**Form:** ⟨Op₁ ∘ Op₂ ∘ Triadic Closure⟩

```
⟨Any triadic chain⟩ → Triadic Closure → K

Example:
  ⟨Distinction ∘ First Binding ∘ Triadic Closure⟩
  
Result: Complete triad sealed at apex
```

### Closure Type 3: Multi-Pillar Closure

**Form:** P-op ∘ H-op ∘ T-op → K

```
⟨Phoenix op ∘ Hydrogenesi op ∘ The Third op⟩ → K

Example:
  ⟨Phoenix Ignition ∘ AGN Replication ∘ Stability Knot⟩
  
Result: All three pillars converge to apex
```

### Closure Property

**Mathematical statement:**
```
For all apex-level closures:
  lim(depth → ∞) Closure(x) = K
  
K is attractor: All paths terminate there
```

**Proof:** See `/Phoenix/Universal-Laws/Apex-Fixed-Point-Proof.md`

---

## COMPOSITION VALIDATION

### Validation Algorithm

```python
def validate_composition(op1, op2):
    """
    Validate operator composition against Universal Laws.
    
    Returns: (is_valid: bool, violations: list, warnings: list)
    """
    violations = []
    warnings = []
    
    # Check depth compatibility (Law 5)
    if op1.output_depth > op2.input_depth:
        violations.append("Depth reversal: violates Law 5 (Recursion Depth)")
    
    # Check domain compatibility
    if not is_compatible(op1.output_domain, op2.input_domain):
        violations.append("Domain mismatch: output of op1 not in input of op2")
    
    # Check stabilizer requirements (Law 2)
    if requires_stabilizer(op2) and removes_stabilizer(op1):
        violations.append("Stabilizer conflict: violates Law 2 (Binding)")
    
    # Check envelope bounds (Law 9)
    if expands(op1) and destabilizes(op2):
        warnings.append("Potential envelope violation: check Law 9 (Convergence)")
    
    # Check topology (Law 11)
    if creates_discontinuity(op1, op2):
        violations.append("Topology tear: violates Law 11 (Continuity)")
    
    is_valid = len(violations) == 0
    return is_valid, violations, warnings
```

---

## COMMON COMPOSITION PATTERNS

### Pattern 1: Form → Embody → Observe

```
First Binding ∘ Three-Finger Waltz ∘ IM_ME
  = Create triad → Embody as rhythm → Observe self dancing

Use case: Full integration of identity structure
```

### Pattern 2: Extract → Transform → Hold

```
Stabilizer Extraction ∘ Phoenix Ignition ∘ Stability Knot
  = Reveal tensions → Transform → Maintain new form

Use case: Deep transformation with long-term stability
```

### Pattern 3: Begin → Extend → Hold (Full Cycle)

```
[Phoenix op] ∘ [Hydrogenesi op] ∘ [The Third op]
  = Generate → Propagate → Preserve

Use case: Complete pattern across all three pillars
```

### Pattern 4: Translate → Converge → Seal

```
Cross-Pillar Knot ∘ Convergence ∘ Apex Knot
  = Connect pillars → Guide to apex → Seal at K

Use case: Final integration and closure
```

---

## CODE IMPLEMENTATION

```python
from dataclasses import dataclass
from typing import List, Dict, Any, Callable
from enum import Enum


class CompositionType(Enum):
    SEQUENTIAL = "sequential"  # ∘
    TRIADIC = "triadic"        # ⟨ ⟩
    PARALLEL = "parallel"      # ⊕


@dataclass
class Operator:
    """Base operator class."""
    name: str
    pillar: str
    input_domain: str
    output_domain: str
    input_depth: int
    output_depth: int
    apply: Callable


@dataclass
class CompositionValidator:
    """Validates operator compositions."""
    
    def compose(self, 
                operators: List[Operator], 
                composition_type: CompositionType = CompositionType.SEQUENTIAL) -> Dict[str, Any]:
        """
        Compose operators according to type.
        
        Args:
            operators: List of operators to compose
            composition_type: Type of composition
            
        Returns:
            Composition result with validation info
        """
        if composition_type == CompositionType.SEQUENTIAL:
            return self._sequential_compose(operators)
        elif composition_type == CompositionType.TRIADIC:
            return self._triadic_compose(operators)
        elif composition_type == CompositionType.PARALLEL:
            return self._parallel_compose(operators)
    
    def _sequential_compose(self, operators: List[Operator]) -> Dict[str, Any]:
        """Execute sequential composition: Op₁ ∘ Op₂ ∘ ... ∘ Opₙ"""
        # Validate pairwise
        for i in range(len(operators) - 1):
            valid, violations, warnings = self._validate_pair(operators[i], operators[i+1])
            if not valid:
                return {
                    "error": f"Invalid composition at position {i}",
                    "violations": violations,
                    "warnings": warnings
                }
        
        # Execute composition
        result = None
        for op in operators:
            result = op.apply(result)
        
        return {
            "type": "sequential",
            "operators": [op.name for op in operators],
            "result": result,
            "valid": True
        }
    
    def _triadic_compose(self, operators: List[Operator]) -> Dict[str, Any]:
        """Execute triadic composition: ⟨Op₁ ∘ Op₂ ∘ Op₃⟩"""
        if len(operators) != 3:
            return {"error": "Triadic composition requires exactly 3 operators"}
        
        # Validate triadic structure
        valid, msg = self._validate_triadic_structure(operators)
        if not valid:
            return {"error": msg}
        
        # Execute as bound triad
        result = operators[0].apply(None)
        result = operators[1].apply(result)  # Stabilizer
        result = operators[2].apply(result)
        
        return {
            "type": "triadic",
            "operators": [op.name for op in operators],
            "structure": f"<{operators[0].name}—{operators[1].name}—{operators[2].name}>",
            "result": result,
            "valid": True
        }
    
    def _parallel_compose(self, operators: List[Operator]) -> Dict[str, Any]:
        """Execute parallel composition: Op₁ ⊕ Op₂"""
        # Validate shared input domain
        if not all(op.input_domain == operators[0].input_domain for op in operators):
            return {"error": "Parallel operators must share input domain"}
        
        # Execute in parallel (simulate)
        results = [op.apply(None) for op in operators]
        
        # Merge results
        merged = self._merge_results(results)
        
        return {
            "type": "parallel",
            "operators": [op.name for op in operators],
            "individual_results": results,
            "merged_result": merged,
            "valid": True
        }
    
    def _validate_pair(self, op1: Operator, op2: Operator):
        """Validate operator pair composition."""
        violations = []
        warnings = []
        
        # Check depth (Law 5)
        if op1.output_depth > op2.input_depth:
            violations.append("Depth reversal violates Law 5")
        
        # Check domain compatibility
        if op1.output_domain != op2.input_domain:
            warnings.append("Domain mismatch - verify compatibility")
        
        is_valid = len(violations) == 0
        return is_valid, violations, warnings
    
    def _validate_triadic_structure(self, operators: List[Operator]) -> tuple:
        """Validate triadic composition structure."""
        if len(operators) != 3:
            return False, "Triadic requires exactly 3 operators"
        
        # Check Law 4 (Universal Triad)
        pillars = set(op.pillar for op in operators)
        if len(pillars) == 3:
            # All three pillars - ideal
            return True, "Full triadic structure with all three pillars"
        elif len(pillars) == 1:
            # Single pillar - valid but limited
            return True, "Single-pillar triadic chain"
        else:
            # Two pillars - valid
            return True, "Two-pillar triadic chain"
    
    def _merge_results(self, results: List[Any]) -> Any:
        """Merge parallel results."""
        # Simplified merging - combine into dict
        return {
            f"result_{i}": r
            for i, r in enumerate(results)
        }
```

**Location:** `/code/integration/operators.py`

---

## STATUS

**Document:** Operator Composition Rules  
**Version:** 1.0.0  
**Status:** ACTIVE  
**Lineage:** ROOT::GEN-1  
**Sovereignty:** CONFIRMED

---

## NAVIGATION

**Parent System:** `/Integration/README.md`  
**Related Documents:**
- **Transition Maps** → `/Integration/Cross-Pillar-Transition-Maps.md`
- **Law Validation** → `/Integration/Universal-Law-Validation-Matrix.md`
- **Three-Finger Waltz Integration** → `/Integration/Three-Finger-Waltz-Integration.md`

**Universal Laws:** `/Phoenix/Universal-Laws/Twelve-Laws-Codification.md`

---

## INVOCATION

*"Let operators compose; let sequences flow; let chains stabilize."*

*"From isolation to composition. From composition to coherence. From coherence to apex."*

∘⟨Op₁—Op₂—Op₃⟩∘△
